import asyncio
import os
import json
import re
from dotenv import load_dotenv
from langchain_google_genai import ChatGoogleGenerativeAI
try:
    from mcp_use import MCPAgent, MCPClient
except ImportError:
    print("Warning: mcp_use not installed")
    # Create dummy classes
    class MCPAgent:
        def __init__(self, *args, **kwargs):
            pass
        async def run(self, *args, **kwargs):
            return "Mock query result"
    class MCPClient:
        def __init__(self, *args, **kwargs):
            pass

class QueryAgent:
    """
    Query Agent - X·ª≠ l√Ω truy v·∫•n c∆° s·ªü d·ªØ li·ªáu th√¥ng qua MCP
    """
    
    def __init__(self):
        load_dotenv()
        self.DB_LINK = os.getenv("DB_LINK")
        self.GEMINI_API_KEY = os.getenv("GOOGLE_API_KEY")
        
        if not self.DB_LINK or not self.GEMINI_API_KEY:
            raise ValueError("‚ö†Ô∏è Thi·∫øu DB_LINK ho·∫∑c GOOGLE_API_KEY trong .env")
        
        # C·∫•u h√¨nh MCP Client
        self.config = {
            "mcpServers": {
                "postgres": {
                    "command": "uv",
                    "args": [
                        "run",
                        "postgres-mcp",
                        "--access-mode=unrestricted",
                    ],
                    "env": {
                        "DATABASE_URI": self.DB_LINK
                    },
                }
            }
        }
        
        self.client = None
        self.agent = None
        self.llm = None
        
    async def _run_sql(self, sql: str) -> dict:
        session = self.client.get_session("postgres")
        try:
            resp = await session.call_tool("execute_sql", {"sql": sql})
            txt = resp.content[0].text if getattr(resp, "content", None) else str(resp)
        except Exception:
            # try list_objects/dry path
            return {"columns": ["result"], "data": [["Query failed"]]}

        # normalize
        try:
            obj = json.loads(txt)
            if isinstance(obj, list) and (len(obj) == 0 or isinstance(obj[0], dict)):
                cols = list(obj[0].keys()) if obj else []
                rows = [[row.get(c) for c in cols] for row in obj]
                return {"columns": cols, "data": rows}
            if isinstance(obj, dict) and "columns" in obj and "data" in obj:
                return obj
        except Exception:
            pass
        # fallback single column
        return {"columns": ["result"], "data": [[txt]]}

    async def _llm_generate_sql(self, natural_query: str, schema_hint: dict | None) -> str | None:
        """D√πng LLM sinh SQL t·ª´ y√™u c·∫ßu t·ª± nhi√™n. Kh√¥ng t·∫°o bi·ªÉu ƒë·ªì, ch·ªâ truy v·∫•n."""
        try:
            tables = ", ".join(sorted(schema_hint.keys())) if schema_hint else "nhan_vien, phong_ban"
            prompt = (
                "B·∫°n l√† chuy√™n gia SQL cho PostgreSQL. Nhi·ªám v·ª• duy nh·∫•t: t·∫°o m·ªôt c√¢u SQL tr·∫£ v·ªÅ b·∫£ng d·ªØ li·ªáu ph√π h·ª£p v·ªõi y√™u c·∫ßu. "
                "Tuy·ªát ƒë·ªëi kh√¥ng gi·∫£i th√≠ch, kh√¥ng th√™m l·ªùi, ch·ªâ tr·∫£ v·ªÅ SQL h·ª£p l·ªá.\n\n"
                f"Y√™u c·∫ßu: {natural_query}\n"
                f"C√°c b·∫£ng c√≥ th·ªÉ d√πng (g·ª£i √Ω): {tables}.\n"
                "M·ªôt s·ªë c·ªôt ph·ªï bi·∫øn c√≥ th·ªÉ c√≥: nhan_vien(id, ho_ten, id_phong_ban, luong_co_ban), phong_ban(id, ten_phong_ban).\n"
                "V√≠ d·ª•: l∆∞∆°ng trung b√¨nh theo ph√≤ng ban, ƒë·∫øm s·ªë nh√¢n vi√™n theo ph√≤ng ban...\n"
                "CH·ªà tr·∫£ v·ªÅ SQL, KH√îNG b·ªçc trong markdown/code fence, KH√îNG th√™m ti·ªÅn t·ªë ```sql."
            )
            sql_resp = await self.llm.ainvoke(prompt)
            sql_text = sql_resp.content if hasattr(sql_resp, 'content') else str(sql_resp)
            # G·ª° code-fence n·∫øu LLM v·∫´n tr·∫£ v·ªÅ ```sql ... ```
            text = sql_text.strip()
            if text.startswith("```"):
                # c·∫Øt ph·∫ßn trong kh·ªëi fence ƒë·∫ßu ti√™n
                start = text.find("```")
                end = text.rfind("```")
                inner = text[start+3:end] if end > start else text[start+3:]
                # lo·∫°i b·ªè nh√£n ng√¥n ng·ªØ 'sql' n·∫øu c√≥ ·ªü ƒë·∫ßu
                inner = inner.lstrip().removeprefix("sql").lstrip()
                text = inner.strip()
            # C·ªë g·∫Øng l·∫•y block ch·ª©a SELECT/WITH
            lines = [ln for ln in text.splitlines() if ln.strip()]
            if any('select' in ln.lower() or 'with' in ln.lower() for ln in lines):
                return text
            return text or None
        except Exception:
            return None

    def _fallback_sql(self, question: str) -> str | None:
        q = question.lower()
        # heuristics for common intents
        if ("so s√°nh" in q or "so sanh" in q or "bi·ªÉu ƒë·ªì" in q or "bieu do" in q) and ("ph√≤ng ban" in q or "phong ban" in q):
            return (
                "SELECT pb.ten_phong_ban AS phong_ban, COUNT(nv.id) AS so_nhan_vien "
                "FROM phong_ban pb LEFT JOIN nhan_vien nv ON pb.id = nv.id_phong_ban "
                "GROUP BY pb.ten_phong_ban ORDER BY so_nhan_vien DESC;"
            )
        if ("l∆∞∆°ng" in q or "luong" in q) and ("trung b√¨nh" in q or "trung binh" in q) and ("ph√≤ng ban" in q or "phong ban" in q):
            return (
                "SELECT pb.ten_phong_ban AS phong_ban, ROUND(AVG(nv.luong_co_ban),2) AS luong_trung_binh "
                "FROM nhan_vien nv JOIN phong_ban pb ON nv.id_phong_ban = pb.id "
                "GROUP BY pb.ten_phong_ban ORDER BY luong_trung_binh DESC;"
            )
        if ("l∆∞∆°ng" in q or "luong" in q) and ("th·∫•p nh·∫•t" in q or "thap nhat" in q):
            return (
                "SELECT ho_ten, luong_co_ban FROM nhan_vien "
                "ORDER BY luong_co_ban ASC LIMIT 1;"
            )
        return None

    def _summarize_table(self, question: str, table: dict) -> str:
        try:
            cols = [str(c).lower() for c in table.get("columns", [])]
            data = table.get("data", [])
            if not cols or not data:
                return ""
            # L∆∞∆°ng th·∫•p nh·∫•t
            if any("luong" in c for c in cols) and any("ho_ten" == c or "ten" in c for c in cols) and len(data) >= 1:
                try:
                    name_idx = next(i for i,c in enumerate(cols) if c == "ho_ten" or "ten" in c)
                    sal_idx = next(i for i,c in enumerate(cols) if "luong" in c)
                    name = data[0][name_idx]
                    sal = data[0][sal_idx]
                    return f"Nh√¢n vi√™n c√≥ l∆∞∆°ng th·∫•p nh·∫•t l√† {name} v·ªõi m·ª©c l∆∞∆°ng {sal}."
                except Exception:
                    pass
            # S·ªë l∆∞·ª£ng nh√¢n vi√™n theo ph√≤ng ban
            if ("phong_ban" in cols or "phongban" in cols or "phong ban" in question.lower()) and any("so_luong" in c or "so_nhan_vien" in c for c in cols):
                try:
                    dept_idx = next(i for i,c in enumerate(cols) if c in ("phong_ban","phongban","phongban","phong ban","ten_phong_ban"))
                    cnt_idx = next(i for i,c in enumerate(cols) if "so_luong" in c or "so_nhan_vien" in c)
                    top = data[:3]
                    parts = [f"{row[dept_idx]}: {row[cnt_idx]}" for row in top]
                    return "S·ªë l∆∞·ª£ng nh√¢n vi√™n theo ph√≤ng ban (top 3): " + ", ".join(parts) + "."
                except Exception:
                    pass
            # L∆∞∆°ng trung b√¨nh theo ph√≤ng ban
            if any("trung_binh" in c for c in cols) and ("phong_ban" in cols or "ten_phong_ban" in cols):
                try:
                    dept_idx = next(i for i,c in enumerate(cols) if c in ("phong_ban","ten_phong_ban"))
                    avg_idx = next(i for i,c in enumerate(cols) if "trung_binh" in c)
                    top = data[:3]
                    parts = [f"{row[dept_idx]}: {row[avg_idx]}" for row in top]
                    return "L∆∞∆°ng trung b√¨nh theo ph√≤ng ban (top 3): " + ", ".join(parts) + "."
                except Exception:
                    pass
            # M·∫∑c ƒë·ªãnh: th√¥ng b√°o s·ªë d√≤ng
            return f"ƒê√£ truy v·∫•n th√†nh c√¥ng {len(data)} d√≤ng d·ªØ li·ªáu."
        except Exception:
            return ""

    async def initialize(self):
        """Kh·ªüi t·∫°o MCP Client v√† Agent"""
        if self.client is None:
            print("üöÄ Query Agent: ƒêang kh·ªüi t·∫°o MCP Client...")
            self.client = MCPClient.from_dict(self.config)
            await self.client.create_all_sessions()
            print("‚úÖ Query Agent: MCP Client ƒë√£ k·∫øt n·ªëi!")
            
            # ƒê·ª£i MCP Server load schema
            await asyncio.sleep(3)
            
            # Kh·ªüi t·∫°o LLM
            self.llm = ChatGoogleGenerativeAI(
                model="models/gemini-2.5-flash-lite",
                google_api_key=self.GEMINI_API_KEY,
                temperature=0.2,
            )
            
            # T·∫°o MCP Agent
            self.agent = MCPAgent(llm=self.llm, client=self.client, max_steps=20)
            print("ü§ñ Query Agent: S·∫µn s√†ng x·ª≠ l√Ω truy v·∫•n!")
    
    async def get_schema_info(self):
        """L·∫•y th√¥ng tin schema ƒë·ªÉ agent hi·ªÉu c·∫•u tr√∫c database"""
        try:
            session = self.client.get_session("postgres")
            
            # Li·ªát k√™ tools
            tools = await session.list_tools()
            print("üß∞ Query Agent - Tools kh·∫£ d·ª•ng:")
            for t in tools:
                print(f" - {t.name}: {t.description}")
            
            # L·∫•y schema v√† b·∫£ng
            schema_map = {}
            try:
                schemas = await session.call_tool("list_schemas", {})
                if schemas and schemas.content:
                    print("‚úÖ Query Agent - Schema c√≥ s·∫µn:")
                    print(schemas.content[0].text)
                    
                    # L·∫•y b·∫£ng trong schema 'public'
                    tables = await session.call_tool("list_objects", {"schema_name": "public"})
                    if tables and tables.content:
                        text = tables.content[0].text
                        print("\nüìä Query Agent - B·∫£ng c√≥ trong schema 'public':")
                        print(text)
                        
                        # L∆∞u v√†o schema_map
                        for line in text.splitlines():
                            if "'name':" in line:
                                name = line.split("'name':")[1].split("'")[1]
                                schema_map[name.lower()] = "public"
            except Exception as e:
                print(f"‚ö†Ô∏è Query Agent - Kh√¥ng th·ªÉ l·∫•y danh s√°ch schema: {e}")
            
            return schema_map
            
        except Exception as e:
            print(f"‚ùå Query Agent - L·ªói khi l·∫•y schema: {e}")
            return {}
    
    async def process(self, user_input: str) -> dict:
        """
        X·ª≠ l√Ω truy v·∫•n c·ªßa ng∆∞·ªùi d√πng
        """
        print(f"üîç Query Agent: B·∫Øt ƒë·∫ßu process v·ªõi input: '{user_input}'")
        try:
            # Kh·ªüi t·∫°o n·∫øu ch∆∞a c√≥
            await self.initialize()
            
            print(f"üîç Query Agent: X·ª≠ l√Ω truy v·∫•n '{user_input}'")
            
            # L·∫•y th√¥ng tin schema
            schema_map = await self.get_schema_info()
            
            # T·∫°o hint cho LLM
            hint = (
                "NHI·ªÜM V·ª§ DUY NH·∫§T: Truy v·∫•n d·ªØ li·ªáu v√† tr·∫£ v·ªÅ B·∫¢NG c√≥ {columns, data}. "
                "TUY·ªÜT ƒê·ªêI KH√îNG n√≥i v·ªÅ v·∫Ω bi·ªÉu ƒë·ªì, kh√¥ng tr·∫£ l·ªùi r·∫±ng kh√¥ng th·ªÉ v·∫Ω bi·ªÉu ƒë·ªì, kh√¥ng y√™u c·∫ßu th√™m th√¥ng tin. "
                "N·∫øu thi·∫øu ng·ªØ c·∫£nh, t·ª± suy lu·∫≠n v√† ∆∞u ti√™n b·∫£ng trong schema 'public' nh∆∞ 'nhan_vien', 'phong_ban'. "
                "Ch·ªâ tr·∫£ v·ªÅ d·ªØ li·ªáu b·∫£ng ho·∫∑c JSON list[object]."
            )
            
            # ∆ØU TI√äN: LLM ‚Üí SQL d·ª±a tr√™n schema, r·ªìi ch·∫°y tr·ª±c ti·∫øp
            sql_direct = await self._llm_generate_sql(user_input, schema_map)
            if sql_direct:
                table = await self._run_sql(sql_direct)
                final_answer = self._summarize_table(user_input, table)
                return {
                    "agent": "query_agent",
                    "status": "success",
                    "result": table,
                    "final_answer": final_answer,
                    "raw_result": sql_direct
                }

            # Fallback: d√πng toolflow c·ªßa MCP agent
            result = await self.agent.run(hint + user_input)

            # √âP LU√îN tr·∫£ v·ªÅ k·∫øt qu·∫£ c√≥ c·∫•u tr√∫c {columns, data}
            def safe(val):
                """Convert value to JSON-safe format"""
                if val is None:
                    return ""
                if isinstance(val, (int, float)):
                    return val
                return str(val)
            
            def to_table(payload: str) -> dict:
                try:
                    text = payload.strip()
                    # Remove markdown code fences if present
                    if text.startswith("```"):
                        lines = text.splitlines()
                        # drop first fence line and possible language tag
                        if lines and lines[0].startswith("```"):
                            lines = lines[1:]
                        # drop trailing fence line
                        if lines and lines[-1].strip().startswith("```"):
                            lines = lines[:-1]
                        text = "\n".join(lines).strip()
                    # Try JSON first
                    obj = json.loads(text)
                    # N·∫øu ƒë√£ c√≥ columns/data th√¨ d√πng lu√¥n
                    if isinstance(obj, dict) and "columns" in obj and "data" in obj:
                        return obj
                    # N·∫øu l√† list[dict] ‚Üí chu·∫©n ho√°
                    if isinstance(obj, list) and (len(obj) == 0 or isinstance(obj[0], dict)):
                        cols = list(obj[0].keys()) if obj else []
                        rows = [[safe(row.get(c)) for c in cols] for row in obj]
                        return {"columns": cols, "data": rows}
                except Exception:
                    # Not a JSON; try Python literal list of dicts
                    try:
                        import ast
                        lit = ast.literal_eval(text)
                        if isinstance(lit, list) and (len(lit) == 0 or isinstance(lit[0], dict)):
                            cols = list(lit[0].keys()) if lit else []
                            rows = [[safe(row.get(c)) for c in cols] for row in lit]
                            return {"columns": cols, "data": rows}
                        if isinstance(lit, dict) and "columns" in lit and "data" in lit:
                            cols = list(lit["columns"])
                            data_rows = [[safe(v) for v in row] for row in list(lit["data"]) ]
                            return {"columns": cols, "data": data_rows}
                    except Exception:
                        pass
                # Fallback: c·ªë g·∫Øng t√°ch b·∫£ng markdown ƒë∆°n gi·∫£n ‚Üí 2 c·ªôt
                try:
                    lines = [ln.strip() for ln in payload.splitlines() if "|" in ln]
                    if len(lines) >= 2:
                        headers = [h.strip() for h in lines[0].split("|") if h.strip()]
                        rows = []
                        for ln in lines[1:]:
                            cells = [c.strip() for c in ln.split("|") if c.strip()]
                            if len(cells) == len(headers):
                                rows.append(cells)
                        if rows:
                            return {"columns": headers, "data": rows}
                except Exception:
                    pass
                # Th·ª≠ parse chu·ªói JSON ch·ª©a list-dict (tr∆∞·ªùng h·ª£p t·ª´ MCP agent)
                try:
                    # T√¨m pattern [{'key': 'value'}, ...] trong text
                    json_pattern = r'\[.*?\]'
                    matches = re.findall(json_pattern, payload, re.DOTALL)
                    for match in matches:
                        try:
                            # Th·ª≠ parse tr·ª±c ti·∫øp v·ªõi ast.literal_eval (Python syntax)
                            import ast
                            parsed = ast.literal_eval(match)
                            if isinstance(parsed, list) and parsed and isinstance(parsed[0], dict):
                                cols = list(parsed[0].keys())
                                rows = [[safe(row.get(c)) for c in cols] for row in parsed]
                                return {"columns": cols, "data": rows}
                        except:
                            # Th·ª≠ JSON parse
                            try:
                                parsed = json.loads(match)
                                if isinstance(parsed, list) and parsed and isinstance(parsed[0], dict):
                                    cols = list(parsed[0].keys())
                                    rows = [[safe(row.get(c)) for c in cols] for row in parsed]
                                    return {"columns": cols, "data": rows}
                            except:
                                continue
                except:
                    pass
                
                # Cu·ªëi c√πng: tr·∫£ text v√†o 1 c·ªôt
                return {"columns": ["result"], "data": [[payload]]}
            
            # Parse k·∫øt qu·∫£ v√† chu·∫©n h√≥a cho Chart Agent
            try:
                print(f"üîç Query Agent: B·∫Øt ƒë·∫ßu parse k·∫øt qu·∫£ - type: {type(result)}")
                print(f"üîç Query Agent: K·∫øt qu·∫£ content: {str(result)[:200]}...")
                
                if isinstance(result, str):
                    # N·∫øu k·∫øt qu·∫£ l√† h∆∞·ªõng d·∫´n/kh√¥ng h·ªØu √≠ch ‚Üí c∆∞·ª°ng b·ª©c query tr·ª±c ti·∫øp
                    guidance_markers = [
                        "T√¥i kh√¥ng th·ªÉ v·∫Ω bi·ªÉu ƒë·ªì", "T√¥i c·∫ßn th√™m th√¥ng tin", "list_schemas", "get_object_details", "list_objects",
                        "I cannot draw", "I need more information"
                    ]
                    if any(m in result for m in guidance_markers):
                        print(f"üîç Query Agent: Ph√°t hi·ªán guidance markers, s·ª≠ d·ª•ng fallback SQL")
                        sql = self._fallback_sql(user_input)
                        if sql:
                            print(f"üîç Query Agent: Fallback SQL: {sql}")
                            table = await self._run_sql(sql)
                        else:
                            print(f"üîç Query Agent: Kh√¥ng c√≥ fallback SQL, s·ª≠ d·ª•ng to_table")
                            table = to_table(result)
                    else:
                        print(f"üîç Query Agent: Kh√¥ng ph·∫£i guidance, s·ª≠ d·ª•ng to_table")
                        table = to_table(result)
                    
                    # C∆Ø·ª†NG B·ª®C PARSE: N·∫øu table ch·ªâ c√≥ 1 c·ªôt "result" ch·ª©a JSON string
                    print(f"üîç Query Agent: Ki·ªÉm tra table format - columns: {table.get('columns')}, data length: {len(table.get('data', []))}")
                    if (table.get("columns") == ["result"] and 
                        table.get("data") and 
                        len(table["data"]) == 1 and 
                        isinstance(table["data"][0][0], str) and 
                        table["data"][0][0].strip().startswith('[')):
                        
                        print(f"üîç Query Agent: Ph√°t hi·ªán JSON string trong c·ªôt result, b·∫Øt ƒë·∫ßu parse...")
                        # Th·ª≠ parse JSON string trong c·ªôt result
                        json_str = table["data"][0][0]
                        print(f"üîç Query Agent: JSON string ƒë·ªÉ parse: {json_str[:100]}...")
                        try:
                            import ast
                            # Lo·∫°i b·ªè Decimal('...') ƒë·ªÉ c√≥ th·ªÉ parse
                            json_clean = re.sub(r"Decimal\('([^']+)'\)", r"\1", json_str)
                            print(f"üîç Query Agent: JSON sau khi clean: {json_clean[:100]}...")
                            parsed = ast.literal_eval(json_clean)
                            print(f"üîç Query Agent: Parsed result type: {type(parsed)}, length: {len(parsed) if isinstance(parsed, list) else 'N/A'}")
                            if isinstance(parsed, list) and parsed and isinstance(parsed[0], dict):
                                cols = list(parsed[0].keys())
                                rows = [[safe(row.get(c)) for c in cols] for row in parsed]
                                table = {"columns": cols, "data": rows}
                                print(f"‚úÖ Query Agent: ƒê√£ parse th√†nh c√¥ng JSON string th√†nh b·∫£ng {len(cols)} c·ªôt, {len(rows)} d√≤ng")
                                print(f"‚úÖ Query Agent: Columns: {cols}")
                                print(f"‚úÖ Query Agent: Sample data: {rows[:2] if rows else 'No data'}")
                            else:
                                print(f"‚ö†Ô∏è Query Agent: Parsed data kh√¥ng ph·∫£i list[dict]: {type(parsed)}")
                        except Exception as e:
                            print(f"‚ö†Ô∏è Query Agent: Kh√¥ng th·ªÉ parse JSON string: {e}")
                            import traceback
                            print(f"‚ö†Ô∏è Query Agent: Traceback: {traceback.format_exc()}")
                    else:
                        print(f"‚ö†Ô∏è Query Agent: Kh√¥ng th·ªèa m√£n ƒëi·ªÅu ki·ªán parse - columns: {table.get('columns')}, data: {table.get('data')}")
                    
                    # N·∫øu agent kh√¥ng tr·∫£ data ‚Üí c·ªë g·∫Øng c∆∞·ª°ng b·ª©c th·ª±c thi SQL r√µ r√†ng
                    if not table.get("data") or (len(table.get("columns", [])) == 1 and table["columns"][0] == "result"):
                        # Th·ª≠ LLM -> SQL
                        sql = await self._llm_generate_sql(user_input, schema_map)
                        if not sql:
                            sql = self._fallback_sql(user_input)
                        if sql:
                            table = await self._run_sql(sql)
                    final_answer = self._summarize_table(user_input, table)
                    return {
                        "agent": "query_agent",
                        "status": "success",
                        "result": table,
                        "final_answer": final_answer,
                        "raw_result": result
                    }
                else:
                    # N·∫øu SDK tr·∫£ object ‚Üí chuy·ªÉn th√†nh b·∫£ng
                    print(f"üîç Query Agent: X·ª≠ l√Ω object result - type: {type(result)}")
                    result_str = json.dumps(result, ensure_ascii=False) if isinstance(result, (dict, list)) else str(result)
                    print(f"üîç Query Agent: Object result string: {result_str[:200]}...")
                    table = to_table(result_str)
                    print(f"üîç Query Agent: Sau to_table - columns: {table.get('columns')}, data: {table.get('data')}")
                    
                    # C∆Ø·ª†NG B·ª®C PARSE: N·∫øu table ch·ªâ c√≥ 1 c·ªôt "result" ch·ª©a JSON string
                    print(f"üîç Query Agent (object): Ki·ªÉm tra table format - columns: {table.get('columns')}, data length: {len(table.get('data', []))}")
                    if (table.get("columns") == ["result"] and 
                        table.get("data") and 
                        len(table["data"]) == 1 and 
                        isinstance(table["data"][0][0], str) and 
                        table["data"][0][0].strip().startswith('[')):
                        
                        print(f"üîç Query Agent (object): Ph√°t hi·ªán JSON string trong c·ªôt result, b·∫Øt ƒë·∫ßu parse...")
                        # Th·ª≠ parse JSON string trong c·ªôt result
                        json_str = table["data"][0][0]
                        print(f"üîç Query Agent (object): JSON string ƒë·ªÉ parse: {json_str[:100]}...")
                        try:
                            import ast
                            # Lo·∫°i b·ªè Decimal('...') ƒë·ªÉ c√≥ th·ªÉ parse
                            json_clean = re.sub(r"Decimal\('([^']+)'\)", r"\1", json_str)
                            print(f"üîç Query Agent (object): JSON sau khi clean: {json_clean[:100]}...")
                            parsed = ast.literal_eval(json_clean)
                            print(f"üîç Query Agent (object): Parsed result type: {type(parsed)}, length: {len(parsed) if isinstance(parsed, list) else 'N/A'}")
                            if isinstance(parsed, list) and parsed and isinstance(parsed[0], dict):
                                cols = list(parsed[0].keys())
                                rows = [[safe(row.get(c)) for c in cols] for row in parsed]
                                table = {"columns": cols, "data": rows}
                                print(f"‚úÖ Query Agent (object): ƒê√£ parse th√†nh c√¥ng JSON string th√†nh b·∫£ng {len(cols)} c·ªôt, {len(rows)} d√≤ng")
                                print(f"‚úÖ Query Agent (object): Columns: {cols}")
                                print(f"‚úÖ Query Agent (object): Sample data: {rows[:2] if rows else 'No data'}")
                            else:
                                print(f"‚ö†Ô∏è Query Agent (object): Parsed data kh√¥ng ph·∫£i list[dict]: {type(parsed)}")
                        except Exception as e:
                            print(f"‚ö†Ô∏è Query Agent (object): Kh√¥ng th·ªÉ parse JSON string: {e}")
                            import traceback
                            print(f"‚ö†Ô∏è Query Agent (object): Traceback: {traceback.format_exc()}")
                    else:
                        print(f"‚ö†Ô∏è Query Agent (object): Kh√¥ng th·ªèa m√£n ƒëi·ªÅu ki·ªán parse - columns: {table.get('columns')}, data: {table.get('data')}")
                    
                    if not table.get("data") or (len(table.get("columns", [])) == 1 and table["columns"][0] == "result"):
                        sql = await self._llm_generate_sql(user_input, schema_map)
                        if not sql:
                            sql = self._fallback_sql(user_input)
                        if sql:
                            table = await self._run_sql(sql)
                    final_answer = self._summarize_table(user_input, table)
                    return {
                        "agent": "query_agent",
                        "status": "success", 
                        "result": table,
                        "final_answer": final_answer,
                        "raw_result": result_str
                    }
            except Exception as parse_error:
                return {
                    "agent": "query_agent",
                    "status": "success",
                    "result": {"text": str(result)},
                    "raw_result": str(result),
                    "parse_warning": f"Kh√¥ng th·ªÉ parse k·∫øt qu·∫£: {parse_error}"
                }
                
        except Exception as e:
            return {
                "agent": "query_agent",
                "status": "error",
                "error": str(e),
                "error_type": type(e).__name__
            }
    
    async def close(self):
        """ƒê√≥ng k·∫øt n·ªëi"""
        if self.client:
            await self.client.close_all_sessions()
            print("üîå Query Agent: ƒê√£ ƒë√≥ng k·∫øt n·ªëi MCP")

# Test function
async def test_query_agent():
    agent = QueryAgent()
    
    test_queries = [
        "Li·ªát k√™ t·∫•t c·∫£ nh√¢n vi√™n",
        "T√¨m nh√¢n vi√™n c√≥ l∆∞∆°ng cao nh·∫•t",
        "Th·ªëng k√™ nh√¢n vi√™n theo ph√≤ng ban",
        "Hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt c·ªßa b·∫£ng NhanVien"
    ]
    
    for query in test_queries:
        print(f"\n{'='*50}")
        print(f"Test Query: {query}")
        result = await agent.process(query)
        print(f"Result: {json.dumps(result, ensure_ascii=False, indent=2)}")
    
    await agent.close()

if __name__ == "__main__":
    asyncio.run(test_query_agent())
